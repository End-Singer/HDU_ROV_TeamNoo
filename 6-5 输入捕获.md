# 输入捕获
本质就是：  当一个特定的电信号变化（事件）发生在单片机引脚上时，系统会立刻记下当时定时器的“钟点”，从而让你可以精确地知道这个事件是“在什么时候”发生的。
它就像一个时间戳相机，为电气事件拍下一张张带有精确时间信息的“照片”。
### **在单片机里的过程：**
-   **那个一直在跑的“超级秒表”** = 定时器（TIM）的**计数器（CNT）**。
-   **“终点线”** = 被配置为输入捕获模式的**GPIO引脚**。  
-   **“运动员碰线”** = 引脚上发生的**电平跳变**（比如从0变到1，这叫上升沿）。
-   **“咔嚓一声拍照”** = 输入捕获单元的动作。当检测到指定的电平跳变时，它会把当前计数器（CNT）的值**瞬间复制**到另一个叫做 **“捕获/比较寄存器（CCR）”** 的地方保存起来。   
-   **“计算结果”** = 你的程序可以去读取CCR寄存器里的值，就知道事件发生的确切时间点了。
### 用途
- 测量脉冲宽度
- 测量宽度
- 测量占空比
### 频率测量
![输入图片说明](/imgs/2025-11-14/PpF3JKYXM0SFM60N.png)
## 输入捕获结构
![输入图片说明](/imgs/2025-11-14/yBGlw7OXPWc4A3jN.png)
## PWMI基本结构
![输入图片说明](/imgs/2025-11-14/9pYFBrpEy6v81Ak3.png)
### 主从触发模式
![输入图片说明](/imgs/2025-11-14/Z5yohU3WXEqWd7xk.png)
## 输入捕获配置步骤
1.  **开启时钟** - 使能定时器和对应GPIO的时钟 
2.  **配置GPIO** - 设置为输入模式（上拉/浮空）  
3.  **选择时钟源** - 配置定时器使用内部时钟
4.  **配置时基单元** - 设置预分频器PSC和自动重装载值ARR 
5.  **配置输入捕获通道** - 设置通道、极性、滤波器、分频等参数    
6.  **配置触发从模式**（可选）- 设置触发源和从模式（用于频率测量）    
7.  **开启定时器** - 启动定时器开始工作
```c
// 1. 开启定时器3和GPIOA的时钟
RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);	// 开启TIM3时钟（APB1总线）
RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	// 开启GPIOA时钟（APB2总线）

// 2. 配置GPIO引脚为上拉输入模式
GPIO_InitTypeDef GPIO_InitStructure;
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;			// 上拉输入模式，引脚默认高电平
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;				// 使用PA6引脚（TIM3通道1）
GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		// 输入速度（虽然输入模式此参数影响不大）
GPIO_Init(GPIOA, &GPIO_InitStructure);

// 3. 配置定时器使用内部时钟源
TIM_InternalClockConfig(TIM3);

// 4. 配置定时器时基单元（基础工作参数）
TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;		// 时钟分频，不分频
TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;	// 向上计数模式
TIM_TimeBaseInitStructure.TIM_Period = 65536 - 1;  				// 自动重装载值ARR，最大计数到65535
TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1; 				// 预分频器PSC，72分频（72MHz/72=1MHz）
TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;			// 重复计数器，高级定时器用，此处为0
TIM_TimeBaseInit(TIM3, &TIM_TimeBaseInitStructure);

// 5. 配置输入捕获参数
TIM_ICInitTypeDef TIM_ICInitStructure;
TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;				// 使用通道1（对应PA6）
TIM_ICInitStructure.TIM_ICFilter = 0xF;						// 输入滤波器值，最大滤波（抗抖动）
TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;	// 捕获上升沿
TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			// 输入分频，不分频（每个边沿都捕获）
TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;	// 直接模式，通道1映射到TI1
TIM_ICInit(TIM3, &TIM_ICInitStructure);

// 6. 配置从模式触发（用于频率测量）
TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);	// 选择TI1FP1作为触发源
TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);	// 从模式：复位模式（检测到触发信号时计数器清零）

// 7. 启动定时器
TIM_Cmd(TIM3, ENABLE);

// 8. 自动计算频率
uint32_t IC_GetFreq(void)
{
	// 计算公式：频率 = 1MHz / 捕获到的周期值
	// TIM_GetCapture1(TIM3) 读取的是信号一个周期的计数值
	// 1000000 / 周期计数值 = 频率(Hz)
	return 1000000 / TIM_GetCapture1(TIM3);
}
```
### 公式
**定时器时钟频率 = 系统时钟 / (PSC + 1)**

**每个计数时间 = 1 / 定时器时钟频率**

**周期计数值 = TIM_GetCapture1(TIM3)**

**信号周期时间 = 周期计数值 × 每个计数时间**

**信号频率 = 1 / 信号周期时间**

**简化公式：信号频率 = 定时器时钟频率 / 周期计数值**

**你的代码：信号频率 = 1000000 / TIM_GetCapture1(TIM3)**
```c
PWM_SetPrescaler(720 - 1); // 输出PWM频率 = 72M / 720 （PSC+1设置为720）/ 100 （ARR+1设置为100） = 1000
	PWM_SetCompare1(50);
	while(1)
	{
		OLED_ShowNum(1, 6, IC_GetFreq(), 5); // 检测到的频率PWM = 72M / 720 （PSC+1设置为720）/ 周期计数值TIM_GetCapture1(TIM3)
	}

```


<!--stackedit_data:
eyJoaXN0b3J5IjpbMTc3NjQyOTY3MV19
-->